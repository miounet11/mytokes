
def parse_inline_tool_blocks(text: str) -> list[dict]:
    """解析内联工具调用，保留文本与工具调用顺序"""
    import re

    blocks = []
    # 匹配 [Calling tool: name]
    tool_pattern = r'\[Calling tool:\s*([^\]]+)\]'
    last_end = 0
    pos = 0

    while pos < len(text):
        match = re.search(tool_pattern, text[pos:])
        if not match:
            break

        match_start = pos + match.start()
        match_end = pos + match.end()

        # 提取工具调用前的文本
        before_text = text[last_end:match_start]
        if before_text and before_text.strip():
            blocks.append({"type": "text", "text": before_text})

        tool_name = match.group(1).strip()
        after_match = text[match_end:]
        
        # 查找 Input: 标记
        input_pattern = r'^[\s]*Input:\s*'
        input_match = re.match(input_pattern, after_match)

        if input_match:
            json_start_pos = match_end + input_match.end()
            try:
                # 使用改进的 extract_json_from_position 进行解析
                input_json, json_end_pos = extract_json_from_position(text, json_start_pos)
                blocks.append({
                    "type": "tool_use",
                    "id": f"toolu_{uuid.uuid4().hex[:12]}",
                    "name": tool_name,
                    "input": input_json,
                })
                last_end = json_end_pos
                pos = json_end_pos
                continue
            except Exception as e:
                logger.warning(f"JSON parse failed for tool {tool_name} at pos {json_start_pos}: {e}")
                
                # 备选方案：如果 extract_json_from_position 失败，尝试定位下一个标记并提取中间文本
                # 标记包括：下一个工具调用、工具结果、或者文本结尾
                next_marker = re.search(r'\[Calling tool:|\[Tool Result\]|\[Tool Error\]', after_match[input_match.end():])
                if next_marker:
                    raw_text = after_match[input_match.end():input_match.end() + next_marker.start()].strip()
                else:
                    raw_text = after_match[input_match.end():].strip()
                
                # 尝试再次解析这个片段
                try:
                    input_json, _ = _try_parse_json(raw_text, 0)
                    blocks.append({
                        "type": "tool_use",
                        "id": f"toolu_{uuid.uuid4().hex[:12]}",
                        "name": tool_name,
                        "input": input_json,
                    })
                    last_end = match_end + input_match.end() + len(raw_text)
                    pos = last_end
                    continue
                except Exception as e:
                    # 记录原始文本以便调试
                    blocks.append({
                        "type": "tool_use",
                        "id": f"toolu_{uuid.uuid4().hex[:12]}",
                        "name": tool_name,
                        "input": {"_raw": raw_text[:2000], "_parse_error": str(e)},
                    })
                    last_end = match_end + input_match.end() + len(raw_text)
                    pos = last_end
                    continue

        # 如果没有找到 Input:，或者格式完全不匹配，将标记本身作为文本保留
        marker_text = text[match_start:match_end]
        if marker_text and marker_text.strip():
            blocks.append({"type": "text", "text": marker_text})
        last_end = match_end
        pos = match_end

    # 添加剩余文本
    if last_end < len(text):
        remaining = text[last_end:]
        if remaining and remaining.strip():
            blocks.append({"type": "text", "text": remaining})

    return blocks
